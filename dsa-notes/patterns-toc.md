# GROK

| Week | Learning Objectives | Resources | Activities | Assessments | Progress Tracker |
|------|---------------------|-----------|------------|-------------|------------------|
| 1 | Understand the fundamentals of arrays in Java, including declaration, initialization, and common operations like insertion, deletion, and traversal. | "Introduction to Algorithms" by CLRS (Chapter 10); GeeksforGeeks Arrays section; Java official documentation on arrays. | Implement a dynamic array class in Java with resize functionality; traverse and print elements of a sample array. | Write a Java program to reverse an array in-place; self-assess by checking against expected output and time complexity (O(n)). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 1 | Analyze time and space complexity of array operations using Big O notation specific to competitive scenarios. | Grokking Algorithms (Chapter on Complexity); Online Big O cheat sheet from Big-O-Algorithm-Complexity. | Calculate complexities for merging two sorted arrays; discuss trade-offs in a personal journal. | Solve 5 LeetCode easy array problems (e.g., Two Sum) and analyze their complexities; quiz yourself on notations. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 2 | Master prefix sum techniques for efficient range sum queries and subarray problems in Java. | GeeksforGeeks Prefix Sum; LeetCode articles on Prefix Sum; Competitive Programming by Steven Halim. | Compute prefix sums for an array; use it to answer multiple range sum queries efficiently. | Solve LeetCode "Range Sum Query - Immutable" and "Subarray Sum Equals K"; verify O(n) time for queries. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 2 | Master string manipulation techniques in Java, including concatenation, substring, and immutability implications. | GeeksforGeeks Strings in Java; Oracle Java Tutorials on Strings. | Build a simple anagram checker using string methods; experiment with StringBuilder for efficiency. | Implement string reversal without built-in methods; test with edge cases like empty strings and palindromes. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 3 | Learn Knuth-Morris-Pratt (KMP) algorithm for efficient pattern searching in strings. | CLRS (Chapter 32 on String Matching); GeeksforGeeks KMP; YouTube: Abdul Bari KMP playlist. | Implement LPS (Longest Prefix Suffix) array; use it to search patterns in text. | Solve LeetCode "Implement strStr()"; compare runtime with naive approach on long strings. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 3 | Implement Rabin-Karp algorithm using rolling hash for multiple pattern matching. | GeeksforGeeks Rabin-Karp; Competitive Programming String Algorithms section. | Code rolling hash function; handle hash collisions with actual comparisons. | Solve "Longest Duplicate Substring" on LeetCode; test with large inputs for efficiency. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 3 | Apply array and string techniques to solve pattern matching problems common in interviews. | LeetCode Explore: Arrays & Hashing; Cracking the Coding Interview (String problems). | Solve "Longest Common Prefix" on LeetCode; adapt solution for Java's string handling. | Timed coding: Solve 3 medium LeetCode string problems in 45 minutes; review solutions for optimizations. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 4 | Implement sliding window technique for subarray and substring problems in Java. | Grokking the Coding Interview (Sliding Window); LeetCode Sliding Window pattern; YouTube: NeetCode Sliding Window. | Maintain a window for maximum in k-sized subarrays; adjust for variable window sizes. | Solve LeetCode "Longest Substring Without Repeating Characters"; optimize for O(n) time. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 4 | Implement singly and doubly linked lists in Java, focusing on node structure and pointer management. | CLRS (Chapter 10 on Linked Lists); GeeksforGeeks Linked List tutorials. | Code a custom LinkedList class with add/remove methods; simulate a LRU cache using doubly linked list. | Debug a provided buggy linked list reversal code; ensure it handles cycles and empty lists correctly. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 4 | Optimize linked list operations for competitive programming, understanding when to use over arrays. | Competitive Programming by Steven Halim (Linked Lists section); YouTube: Abdul Bari's Linked List playlist. | Implement cycle detection using Floyd's algorithm; compare performance with array-based approaches. | Solve LeetCode "Merge Two Sorted Lists"; measure runtime on large inputs and optimize if > O(n). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 5 | Understand stack data structure principles and Java's Stack class usage in recursion and parsing. | GeeksforGeeks Stacks; Java Collections Framework docs. | Simulate parentheses validation using a stack; implement iterative inorder tree traversal with stack. | Code a next greater element finder; test with random arrays and verify against brute force. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 5 | Utilize monotonic stacks for efficient next greater/lesser element problems. | LeetCode Monotonic Stack problems; GeeksforGeeks Monotonic Stack; YouTube: takeUforward Monotonic. | Implement daily temperatures problem using monotonic decreasing stack. | Solve LeetCode "Next Greater Element II"; ensure O(n) time with circular array handling. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 5 | Utilize queues for breadth-first search and sliding window applications in Java. | CLRS (Chapter 22 on BFS); GeeksforGeeks Queues. | Implement a queue using two stacks; apply to level-order tree traversal. | Solve LeetCode "Implement Queue using Stacks"; assess by enqueue/dequeue operations on 1000 elements. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 6 | Design and implement binary trees in Java, including node definition and basic traversals (inorder, preorder, postorder). | Grokking the Coding Interview (Trees section); Binary Tree visualizations on VisuAlgo. | Build a binary tree from array input; perform recursive traversals and print results. | Implement height calculation and diameter finding; self-test with balanced/unbalanced trees. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 6 | Master binary search trees (BST) operations: insertion, deletion, search, and validation. | CLRS (Chapter 12); GeeksforGeeks BST tutorials. | Code a BST class with all CRUD operations; insert a sorted array and verify balance. | Solve LeetCode "Validate Binary Search Tree"; include edge cases like duplicates and null roots. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 6 | Apply tree traversals to solve problems like lowest common ancestor (LCA) in interviews. | LeetCode Tree problems; YouTube: NeetCode Tree playlist. | Implement LCA using recursion; test on sample trees with multiple queries. | Timed: Solve 4 LeetCode medium tree problems; review for space optimizations (O(h) height). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 7 | Understand graph representations: adjacency list vs. matrix in Java for sparse/dense graphs. | CLRS (Chapter 22); GeeksforGeeks Graph tutorials. | Convert edge list to adjacency list; compare memory usage for a sample graph. | Implement graph from input; validate connectivity for disconnected components. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 7 | Perform depth-first search (DFS) and breadth-first search (BFS) on graphs using Java recursion and queues. | Competitive Programming (Graph traversal); VisuAlgo Graph DFS/BFS. | Code DFS for cycle detection in undirected graphs; BFS for shortest path in unweighted graph. | Solve LeetCode "Number of Islands"; test on grid inputs up to 100x100. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 7 | Solve graph-based problems like topological sort and connected components for FAANG prep. | LeetCode Graph Explore; Cracking the Coding Interview (Graph chapter). | Implement Kahn's algorithm for topological sort; apply to course prerequisite problem. | Timed coding: 3 medium LeetCode graph problems (e.g., Course Schedule); analyze for O(V+E) efficiency. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 8 | Implement Union-Find (Disjoint Set Union) with path compression and union by rank for graph connectivity. | CLRS (Chapter 21); GeeksforGeeks Union-Find; YouTube: WilliamFiset DSU. | Code DSU class; apply to detect cycles in undirected graphs. | Solve LeetCode "Redundant Connection"; verify near O(1) time per operation. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 8 | Implement Kruskal's algorithm for Minimum Spanning Tree using DSU. | Competitive Programming (MST section); GeeksforGeeks Kruskal. | Sort edges and union sets; compute total MST weight. | Solve LeetCode "Min Cost to Connect All Points"; test on dense graphs. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 8 | Implement Bellman-Ford algorithm for shortest paths with negative weights. | CLRS (Chapter 24); GeeksforGeeks Bellman-Ford. | Relax edges V-1 times; detect negative cycles. | Solve LeetCode "Network Delay Time" variant; handle negative edges. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 9 | Implement hashing with Java's HashMap and handle collisions using chaining. | CLRS (Chapter 11); Java HashMap source code analysis on GitHub. | Custom hash table implementation with linear probing; load factor management. | Solve LeetCode "Group Anagrams" using hash; verify no collisions affect correctness. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 9 | Apply hashing to optimize lookups in competitive problems like subarray sums. | GeeksforGeeks Hashing for CP; YouTube: Hashing tricks for CP. | Use HashMap for two-sum variants; track frequencies in sliding windows. | Solve 5 LeetCode hashing problems; self-assess by refactoring array solutions to hash-based. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 9 | Understand quicksort, mergesort, and heapsort implementations in Java with pivot choices. | CLRS (Chapter 7 on Sorting); Java's Arrays.sort() internals. | Implement mergesort recursively; quicksort with random pivot to avoid worst-case. | Code and compare runtimes on random/sorted arrays of size 10^5; plot informal graph. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 10 | Optimize searching with binary search and its variants in sorted arrays. | Grokking Algorithms (Binary Search); GeeksforGeeks Binary Search. | Implement lower/upper bound functions; apply to rotated sorted array search. | Solve LeetCode "Search in Rotated Sorted Array"; test with duplicates and single elements. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 10 | Tackle advanced search problems like finding peaks or using binary search on answers. | Competitive Programming (Binary Search chapter); Codeforces problem set. | Solve "Aggressive Cows" problem; binary search on minimum distance. | Timed: 4 binary search problems from LeetCode/Codeforces; ensure logarithmic time. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 10 | Utilize two pointers technique for problems in sorted arrays and linked lists. | LeetCode Two Pointers pattern; Grokking the Coding Interview (Two Pointers). | Implement pair sum in sorted array; remove duplicates from sorted list. | Solve LeetCode "Container With Most Water"; optimize from O(n^2) to O(n). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 11 | Grasp dynamic programming (DP) fundamentals: memoization vs. tabulation in Java. | CLRS (Chapter 15); YouTube: DP playlist by takeUforward. | Implement Fibonacci with memoization; convert to bottom-up tabulation. | Solve LeetCode "Climbing Stairs"; verify results match recursion with cache. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 11 | Apply 1D DP to problems like knapsack and longest increasing subsequence. | GeeksforGeeks DP tutorials; Cracking the Coding Interview (DP section). | Code 0/1 knapsack with space optimization; LIS using patience sorting. | Solve 3 medium DP problems (e.g., House Robber); assess space from O(n^2) to O(n). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 11 | Apply Kadane's algorithm for maximum subarray sum and its variants in DP contexts. | GeeksforGeeks Kadane; LeetCode Maximum Subarray article. | Implement standard Kadane; extend to circular maximum subarray. | Solve LeetCode "Maximum Subarray"; handle all negative cases and large arrays. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 12 | Master 2D DP for grid paths and edit distance in interview scenarios. | LeetCode DP Explore; Competitive Programming DP examples. | Implement minimum path sum in matrix; Levenshtein distance calculator. | Timed coding: "Unique Paths" and "Edit Distance"; review for overlapping subproblems. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 12 | Design greedy algorithms for interval scheduling and Huffman coding in Java. | CLRS (Chapter 16); Grokking Greedy. | Implement activity selection greedy; fractional knapsack comparator. | Solve LeetCode "Jump Game"; test greedy vs. DP approaches for optimality. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 12 | Analyze when greedy fails and combine with other paradigms for CP problems. | Codeforces greedy tags; YouTube: Greedy proofs. | Solve "Minimum Platforms" problem; prove greedy choice property in notes. | Solve 4 greedy problems; self-quiz on counterexamples where DP is needed. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 13 | Implement backtracking for permutations, subsets, and N-Queens in Java. | GeeksforGeeks Backtracking; LeetCode Backtracking section. | Generate all permutations using recursion; Sudoku solver skeleton. | Code N-Queens for n=8; count solutions and visualize board states. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 13 | Optimize backtracking with pruning for larger inputs in competitive settings. | Competitive Programming (Backtracking chapter); Pruning techniques on CP-Algorithms. | Solve word search in grid with early termination; combination sum II. | Timed: 3 LeetCode backtracking mediums; measure time savings from pruning. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 13 | Understand heap data structures: min-heap and max-heap using Java's PriorityQueue. | CLRS (Chapter 6); GeeksforGeeks Heaps. | Implement heapify and extract-min; k-largest elements finder. | Solve LeetCode "Kth Largest Element"; compare with sorting approach. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 14 | Apply heaps to median maintenance and Dijkstra's shortest path. | YouTube: Heap applications; CP-Algorithms Heaps. | Running median using two heaps; priority queue for graph distances. | Implement Dijkstra with heap; test on graph with 100 nodes for O((V+E)logV). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 14 | Build tries for efficient string storage and autocomplete features in Java. | GeeksforGeeks Trie; LeetCode Trie problems. | Implement TrieNode and insert/search; word break using trie. | Solve "Implement Trie (Prefix Tree)"; add delete functionality and test. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 14 | Use advanced structures like segment trees for range queries and updates. | CP-Algorithms Segment Trees; YouTube: Segment Tree tutorials. | Code a simple segment tree for sum queries; lazy propagation basics. | Solve range sum query problem; verify updates in O(log n) on array of 10^5. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 15 | Explore Fenwick Tree (Binary Indexed Tree) for prefix sums in competitive programming. | GeeksforGeeks Fenwick Tree; Codeforces practice. | Implement update and query functions; apply to inversion counting. | Solve "Fenwick Tree" sample problems; compare with segment tree efficiency. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 15 | Implement Sieve of Eratosthenes for prime number generation and factorization basics. | Competitive Programming (Number Theory); GeeksforGeeks Sieve. | Generate primes up to 10^6; use for prime factorization. | Solve LeetCode "Count Primes"; optimize space with segmented sieve if needed. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 15 | Master fast modular arithmetic operations like exponentiation in Java. | CP-Algorithms Number Theory; GeeksforGeeks Modular Exponentiation. | Implement binary exponentiation for mod pow; apply to matrix exponentiation skeleton. | Solve Codeforces modular problems; ensure handles large exponents in O(log n). | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 16 | Integrate multiple DSA concepts in complex problems like graph + DP for TSP. | LeetCode Hard problems; Competitive Programming advanced chapters. | Held-Karp DP for TSP; bitmasking for state representation. | Timed mock interview: Solve 2 hard problems combining topics; record thought process. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 16 | Practice bit manipulation tricks for optimization in Java (e.g., XOR, shifts). | Cracking the Coding Interview (Bits); GeeksforGeeks Bit Manipulation. | Implement single number finder using XOR; bit counting. | Solve LeetCode "Single Number" series; quiz on 2's complement behaviors. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 16 | Review and optimize solutions for time/space in FAANG-style constraints. | LeetCode Discuss optimizations; Big-O analysis tools. | Refactor 5 previous solutions for better constants; profile with Java VisualVM. | Portfolio review: Select 10 problems, optimize, and document improvements. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 17 | Simulate full interview rounds with timed coding and system design elements. | Pramp or Interviewing.io mocks; FAANG interview prep books. | Conduct self-mock: 45-min coding + 15-min discussion on trade-offs. | Debrief sessions: Rate explanations on clarity (1-10); iterate based on weaknesses. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: |
| 17 | Build a competitive programming portfolio with solved problems and explanations. | Codeforces/LeetCode profile; GitHub repo for Java solutions. | Upload 50+ solutions with READMEs explaining approaches and complexities. | Peer review simulation: Explain 3 solutions aloud; self-assess communication. | - [ ] Not Started<br>- [ ] In Progress<br>- [ ] Completed<br>Notes: